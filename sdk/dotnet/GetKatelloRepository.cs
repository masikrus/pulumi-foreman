// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Foreman
{
    public static class GetKatelloRepository
    {
        public static Task<GetKatelloRepositoryResult> InvokeAsync(GetKatelloRepositoryArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<GetKatelloRepositoryResult>("foreman:index/getKatelloRepository:getKatelloRepository", args ?? new GetKatelloRepositoryArgs(), options.WithDefaults());

        public static Output<GetKatelloRepositoryResult> Invoke(GetKatelloRepositoryInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<GetKatelloRepositoryResult>("foreman:index/getKatelloRepository:getKatelloRepository", args ?? new GetKatelloRepositoryInvokeArgs(), options.WithDefaults());

        public static Output<GetKatelloRepositoryResult> Invoke(GetKatelloRepositoryInvokeArgs args, InvokeOutputOptions options)
            => global::Pulumi.Deployment.Instance.Invoke<GetKatelloRepositoryResult>("foreman:index/getKatelloRepository:getKatelloRepository", args ?? new GetKatelloRepositoryInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetKatelloRepositoryArgs : global::Pulumi.InvokeArgs
    {
        [Input("name", required: true)]
        public string Name { get; set; } = null!;

        public GetKatelloRepositoryArgs()
        {
        }
        public static new GetKatelloRepositoryArgs Empty => new GetKatelloRepositoryArgs();
    }

    public sealed class GetKatelloRepositoryInvokeArgs : global::Pulumi.InvokeArgs
    {
        [Input("name", required: true)]
        public Input<string> Name { get; set; } = null!;

        public GetKatelloRepositoryInvokeArgs()
        {
        }
        public static new GetKatelloRepositoryInvokeArgs Empty => new GetKatelloRepositoryInvokeArgs();
    }


    [OutputType]
    public sealed class GetKatelloRepositoryResult
    {
        public readonly bool __meta_;
        public readonly string AnsibleCollectionRequirements;
        public readonly string ChecksumType;
        public readonly string ContentType;
        public readonly string DebArchitectures;
        public readonly string DebComponents;
        public readonly string DebReleases;
        public readonly string Description;
        public readonly string DockerTagsWhitelist;
        public readonly string DockerUpstreamName;
        public readonly int DownloadConcurrency;
        public readonly string DownloadPolicy;
        public readonly int GpgKeyId;
        public readonly int HttpProxyId;
        public readonly string HttpProxyPolicy;
        /// <summary>
        /// The provider-assigned unique ID for this managed resource.
        /// </summary>
        public readonly string Id;
        public readonly string IgnorableContent;
        public readonly bool IgnoreGlobalProxy;
        public readonly string Label;
        public readonly bool MirrorOnSync;
        public readonly string MirroringPolicy;
        public readonly string Name;
        public readonly int ProductId;
        public readonly bool Unprotected;
        public readonly string UpstreamPassword;
        public readonly string UpstreamUsername;
        public readonly string Url;
        public readonly bool VerifySslOnSync;

        [OutputConstructor]
        private GetKatelloRepositoryResult(
            bool __meta_,

            string ansibleCollectionRequirements,

            string checksumType,

            string contentType,

            string debArchitectures,

            string debComponents,

            string debReleases,

            string description,

            string dockerTagsWhitelist,

            string dockerUpstreamName,

            int downloadConcurrency,

            string downloadPolicy,

            int gpgKeyId,

            int httpProxyId,

            string httpProxyPolicy,

            string id,

            string ignorableContent,

            bool ignoreGlobalProxy,

            string label,

            bool mirrorOnSync,

            string mirroringPolicy,

            string name,

            int productId,

            bool unprotected,

            string upstreamPassword,

            string upstreamUsername,

            string url,

            bool verifySslOnSync)
        {
            this.__meta_ = __meta_;
            AnsibleCollectionRequirements = ansibleCollectionRequirements;
            ChecksumType = checksumType;
            ContentType = contentType;
            DebArchitectures = debArchitectures;
            DebComponents = debComponents;
            DebReleases = debReleases;
            Description = description;
            DockerTagsWhitelist = dockerTagsWhitelist;
            DockerUpstreamName = dockerUpstreamName;
            DownloadConcurrency = downloadConcurrency;
            DownloadPolicy = downloadPolicy;
            GpgKeyId = gpgKeyId;
            HttpProxyId = httpProxyId;
            HttpProxyPolicy = httpProxyPolicy;
            Id = id;
            IgnorableContent = ignorableContent;
            IgnoreGlobalProxy = ignoreGlobalProxy;
            Label = label;
            MirrorOnSync = mirrorOnSync;
            MirroringPolicy = mirroringPolicy;
            Name = name;
            ProductId = productId;
            Unprotected = unprotected;
            UpstreamPassword = upstreamPassword;
            UpstreamUsername = upstreamUsername;
            Url = url;
            VerifySslOnSync = verifySslOnSync;
        }
    }
}
